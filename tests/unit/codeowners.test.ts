/**
 * RepoHygiene - CODEOWNERS Generator Tests
 */

import { describe, it, expect } from 'vitest';
import {
    generateCodeowners,
    parseCodeowners,
    compareCodeowners,
} from '../../src/modules/codeowners/generator.js';
import { emailToUsername } from '../../src/modules/codeowners/analyzer.js';
import type { FileOwnership } from '../../src/types/index.js';

describe('emailToUsername', () => {
    it('extracts username from email', () => {
        expect(emailToUsername('john@example.com')).toBe('@john');
    });

    it('handles email with dots', () => {
        expect(emailToUsername('john.doe@example.com')).toBe('@john.doe');
    });

    it('maps to team when in teamMappings', () => {
        const teamMappings = {
            'frontend-team': ['john', 'jane'],
        };
        expect(emailToUsername('john@example.com', teamMappings)).toBe('@frontend-team');
    });
});

describe('generateCodeowners', () => {
    const mockOwnerships: FileOwnership[] = [
        {
            path: '/src/',
            owners: [
                { author: 'John', email: 'john@example.com', commits: 50, linesChanged: 1000, lastCommit: new Date() },
                { author: 'Jane', email: 'jane@example.com', commits: 30, linesChanged: 500, lastCommit: new Date() },
            ],
            suggestedOwner: 'john@example.com',
        },
        {
            path: '/docs/',
            owners: [
                { author: 'Jane', email: 'jane@example.com', commits: 20, linesChanged: 200, lastCommit: new Date() },
            ],
            suggestedOwner: 'jane@example.com',
        },
    ];

    it('generates valid CODEOWNERS content', () => {
        const content = generateCodeowners(mockOwnerships);
        expect(content).toContain('/src/');
        expect(content).toContain('@john');
        expect(content).toContain('/docs/');
        expect(content).toContain('@jane');
    });

    it('includes header comment', () => {
        const content = generateCodeowners(mockOwnerships);
        expect(content).toContain('# CODEOWNERS file generated by RepoHygiene');
    });

    it('limits owners per path when maxOwnersPerPath is set', () => {
        const content = generateCodeowners(mockOwnerships, { maxOwnersPerPath: 1 });
        const srcLine = content.split('\n').find(l => l.startsWith('/src/'));
        expect(srcLine).toBeDefined();
        // Should only have one owner
        const owners = srcLine!.split(' ').filter(s => s.startsWith('@'));
        expect(owners.length).toBe(1);
    });
});

describe('parseCodeowners', () => {
    it('parses simple CODEOWNERS file', () => {
        const content = `/src/ @john
/docs/ @jane @bob`;
        const result = parseCodeowners(content);

        expect(result.get('/src/')).toEqual(['@john']);
        expect(result.get('/docs/')).toEqual(['@jane', '@bob']);
    });

    it('ignores comments', () => {
        const content = `# This is a comment
/src/ @john`;
        const result = parseCodeowners(content);

        expect(result.size).toBe(1);
        expect(result.get('/src/')).toEqual(['@john']);
    });

    it('ignores empty lines', () => {
        const content = `/src/ @john

/docs/ @jane`;
        const result = parseCodeowners(content);

        expect(result.size).toBe(2);
    });
});

describe('compareCodeowners', () => {
    const mockOwnerships: FileOwnership[] = [
        {
            path: '/src/',
            owners: [{ author: 'John', email: 'john@example.com', commits: 50, linesChanged: 1000, lastCommit: new Date() }],
            suggestedOwner: 'john@example.com',
        },
        {
            path: '/new/',
            owners: [{ author: 'Jane', email: 'jane@example.com', commits: 20, linesChanged: 200, lastCommit: new Date() }],
            suggestedOwner: 'jane@example.com',
        },
    ];

    it('detects new paths', () => {
        const existing = new Map([['/src/', ['@john']]]);
        const conflicts = compareCodeowners(mockOwnerships, existing);

        const newConflict = conflicts.find(c => c.type === 'new');
        expect(newConflict).toBeDefined();
        expect(newConflict?.path).toBe('/new/');
    });

    it('detects different owners', () => {
        const existing = new Map([['/src/', ['@alice']]]);
        const conflicts = compareCodeowners(mockOwnerships, existing);

        const diffConflict = conflicts.find(c => c.type === 'different');
        expect(diffConflict).toBeDefined();
    });
});
