/**
 * RepoHygiene - CODEOWNERS Generator
 * Generates CODEOWNERS file content from analysis
 */

import type { FileOwnership } from '../../types/index.js';
import { emailToUsername } from './analyzer.js';

const HEADER = `# CODEOWNERS file generated by RepoHygiene
# https://github.com/your-username/repohygiene
#
# This file defines code ownership for automatic review assignment.
# For more info: https://docs.github.com/en/repositories/managing-your-repositorys-settings-and-features/customizing-your-repository/about-code-owners

`;

export interface GeneratorOptions {
  readonly teamMappings?: Record<string, readonly string[]>;
  readonly includeStats?: boolean;
  readonly maxOwnersPerPath?: number;
}

/**
 * Generate CODEOWNERS file content
 */
export function generateCodeowners(
  ownerships: readonly FileOwnership[],
  options: GeneratorOptions = {}
): string {
  const { teamMappings, includeStats = true, maxOwnersPerPath = 3 } = options;
  const lines: string[] = [HEADER];

  // Group by top-level directory for better organization
  const grouped = groupByTopLevel(ownerships);

  for (const [group, paths] of Object.entries(grouped)) {
    if (includeStats) {
      lines.push(`# ${group}`);
    }

    for (const ownership of paths) {
      const owners = ownership.owners
        .slice(0, maxOwnersPerPath)
        .map((o) => emailToUsername(o.email, teamMappings))
        .join(' ');

      if (includeStats && ownership.owners[0]) {
        const topOwner = ownership.owners[0];
        lines.push(`# ${topOwner.commits} commits by ${topOwner.author}`);
      }

      lines.push(`${ownership.path} ${owners}`);
      lines.push('');
    }
  }

  return lines.join('\n');
}

/**
 * Group ownerships by top-level directory
 */
function groupByTopLevel(ownerships: readonly FileOwnership[]): Record<string, FileOwnership[]> {
  const groups: Record<string, FileOwnership[]> = {};

  for (const ownership of ownerships) {
    // Extract top-level directory
    const parts = ownership.path.split('/').filter(Boolean);
    const topLevel = parts[0] ?? 'root';

    if (!groups[topLevel]) {
      groups[topLevel] = [];
    }
    groups[topLevel].push(ownership);
  }

  return groups;
}

/**
 * Parse existing CODEOWNERS file
 */
export function parseCodeowners(content: string): Map<string, string[]> {
  const ownership = new Map<string, string[]>();
  const lines = content.split('\n');

  for (const line of lines) {
    const trimmed = line.trim();

    // Skip comments and empty lines
    if (trimmed.startsWith('#') || trimmed === '') {
      continue;
    }

    // Parse: path @owner1 @owner2 ...
    const parts = trimmed.split(/\s+/);
    if (parts.length >= 2) {
      const path = parts[0];
      const owners = parts.slice(1).filter((p) => p !== undefined);
      if (path !== undefined) {
        ownership.set(path, owners);
      }
    }
  }

  return ownership;
}

/**
 * Compare generated vs existing CODEOWNERS
 */
export interface CodeownersConflict {
  readonly path: string;
  readonly existingOwners: readonly string[];
  readonly suggestedOwners: readonly string[];
  readonly type: 'missing' | 'different' | 'new';
}

export function compareCodeowners(
  generated: readonly FileOwnership[],
  existing: Map<string, string[]>,
  teamMappings?: Record<string, readonly string[]>
): CodeownersConflict[] {
  const conflicts: CodeownersConflict[] = [];
  const generatedPaths = new Set(generated.map((o) => o.path));

  // Check for differences in existing paths
  for (const ownership of generated) {
    const existingOwners = existing.get(ownership.path);
    const suggestedOwners = ownership.owners.map((o) => emailToUsername(o.email, teamMappings));

    if (!existingOwners) {
      conflicts.push({
        path: ownership.path,
        existingOwners: [],
        suggestedOwners,
        type: 'new',
      });
    } else if (!arraysEqual(existingOwners, suggestedOwners.slice(0, existingOwners.length))) {
      conflicts.push({
        path: ownership.path,
        existingOwners,
        suggestedOwners,
        type: 'different',
      });
    }
  }

  // Check for paths in existing that aren't in generated
  for (const [path, owners] of existing) {
    if (!generatedPaths.has(path)) {
      conflicts.push({
        path,
        existingOwners: owners,
        suggestedOwners: [],
        type: 'missing',
      });
    }
  }

  return conflicts;
}

function arraysEqual(a: readonly string[], b: readonly string[]): boolean {
  if (a.length !== b.length) return false;
  return a.every((val, i) => val === b[i]);
}
